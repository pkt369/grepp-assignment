import logging
from django.core.management.base import BaseCommand
from django.db import connection
from django.test.utils import CaptureQueriesContext
from django.contrib.auth import get_user_model
from rest_framework.test import APIRequestFactory
from rest_framework.request import Request
from tests.views import TestViewSet
from courses.views import CourseViewSet
from payments.views import PaymentViewSet

User = get_user_model()


class Command(BaseCommand):
    help = 'Run EXPLAIN ANALYZE on actual queries generated by ViewSets'

    def add_arguments(self, parser):
        parser.add_argument(
            '--output',
            type=str,
            default='explain_results.txt',
            help='Output file for EXPLAIN ANALYZE results'
        )

    def handle(self, *args, **options):
        # Disable logging during query analysis
        logging.disable(logging.CRITICAL)
        output_file = options['output']

        self.stdout.write(self.style.SUCCESS('Capturing actual queries from ViewSets...'))

        results = []
        factory = APIRequestFactory()

        # Get a test user
        user, _ = User.objects.get_or_create(
            username='explain_test_user',
            defaults={'email': 'explain@test.com'}
        )

        # Define test scenarios
        scenarios = [
            {
                'name': 'Test List - Basic Query',
                'description': 'Basic test list with annotate for registration_count and is_registered_flag',
                'viewset': TestViewSet,
                'action': 'list',
                'query_params': {},
            },
            {
                'name': 'Test List - FTS Search',
                'description': 'Full-text search on tests using search_vector index',
                'viewset': TestViewSet,
                'action': 'list',
                'query_params': {'search': 'Django'},
            },
            {
                'name': 'Test List - Status Filter (available)',
                'description': 'Filter tests by availability (start_at, end_at)',
                'viewset': TestViewSet,
                'action': 'list',
                'query_params': {'status': 'available'},
            },
            {
                'name': 'Test List - Popular Sort',
                'description': 'Sort by registration count (annotated field)',
                'viewset': TestViewSet,
                'action': 'list',
                'query_params': {'sort': 'popular'},
            },
            {
                'name': 'Course List - FTS Search',
                'description': 'Full-text search on courses using search_vector index',
                'viewset': CourseViewSet,
                'action': 'list',
                'query_params': {'search': 'Python'},
            },
            {
                'name': 'Payment List - With Content Type Join',
                'description': 'Payment list with select_related on content_type',
                'viewset': PaymentViewSet,
                'action': 'list',
                'query_params': {},
            },
        ]

        # Capture and analyze queries for each scenario
        for scenario in scenarios:
            self.stdout.write(f"\nAnalyzing: {scenario['name']}")

            try:
                # Create request
                django_request = factory.get('/api/', scenario['query_params'])
                django_request.user = user

                # Wrap with DRF Request
                request = Request(django_request)
                request.user = user

                # Get viewset instance
                viewset = scenario['viewset']()
                viewset.request = request
                viewset.format_kwarg = None

                # Capture queries
                with CaptureQueriesContext(connection) as queries:
                    if scenario['action'] == 'list':
                        queryset = viewset.get_queryset()
                        # Apply filters
                        queryset = viewset.filter_queryset(queryset)
                        # Force queryset evaluation with LIMIT 20
                        list(queryset[:20])

                # Find the main query (usually the last or longest one)
                if queries:
                    # Get the query that contains the main table name
                    main_query = None
                    for q in queries:
                        sql = q['sql']
                        # Skip simple queries like COUNT(*)
                        if 'SELECT' in sql and ('tests' in sql.lower() or 'courses' in sql.lower() or 'payments' in sql.lower()):
                            if 'LIMIT' in sql or 'ORDER BY' in sql:
                                main_query = sql
                                break

                    if not main_query and queries:
                        main_query = queries[-1]['sql']

                    if main_query:
                        # Run EXPLAIN ANALYZE on the captured query
                        explain_sql = f"EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT) {main_query}"

                        with connection.cursor() as cursor:
                            cursor.execute(explain_sql)
                            rows = cursor.fetchall()

                        # Format results
                        result_text = f"\n{'=' * 80}\n"
                        result_text += f"Query: {scenario['name']}\n"
                        result_text += f"Description: {scenario['description']}\n"
                        result_text += f"{'=' * 80}\n\n"
                        result_text += "SQL:\n"
                        result_text += main_query + "\n\n"
                        result_text += "EXPLAIN ANALYZE:\n"
                        result_text += "-" * 80 + "\n"

                        for row in rows:
                            result_text += row[0] + "\n"

                        result_text += "\n"

                        results.append(result_text)

                        # Print summary
                        self.stdout.write(self.style.SUCCESS(f"  ✓ Analyzed successfully"))

                        # Check for index usage
                        explain_output = "\n".join([row[0] for row in rows])
                        if "Index Scan" in explain_output or "Bitmap Index Scan" in explain_output:
                            self.stdout.write(self.style.SUCCESS("  ✓ Using index"))
                        elif "Seq Scan" in explain_output:
                            self.stdout.write(self.style.WARNING("  ⚠ Sequential scan detected"))
                    else:
                        self.stdout.write(self.style.WARNING(f"  ⚠ No suitable query found"))

            except Exception as e:
                error_text = f"\n{'=' * 80}\n"
                error_text += f"Query: {scenario['name']}\n"
                error_text += f"ERROR: {str(e)}\n"
                error_text += f"{'=' * 80}\n\n"
                results.append(error_text)
                self.stdout.write(self.style.ERROR(f"  ✗ Error: {str(e)}"))

        # Save results to file
        with open(output_file, 'w') as f:
            f.write("EXPLAIN ANALYZE RESULTS\n")
            f.write(f"{'=' * 80}\n\n")
            for result in results:
                f.write(result)

        self.stdout.write(
            self.style.SUCCESS(f'\nEXPLAIN ANALYZE complete! Results saved to {output_file}')
        )
